
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/itsankoff/gotcha/client/client.go (31.1%)</option>
				
				<option value="file1">github.com/itsankoff/gotcha/client/ws.go (85.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "bufio"
        "errors"
        "fmt"
        "github.com/itsankoff/gotcha/common"
        "io/ioutil"
        "log"
        "os"
        "time"
)

// Main object which represents the chat
// client
type Client struct {
        Out           chan *common.Message
        transport     Transport
        contacts      []string
        userId        string
        username      string
        password      string
        authenticated bool
}

// New creates a new chat client and binds the underlying
// transport for sending/receiving messages and files
func New(transport Transport) *Client <span class="cov8" title="1">{
        client := &amp;Client{
                Out:       make(chan *common.Message),
                transport: transport,
        }

        client.transport.SetReceiver(client.Out)
        return client
}</span>

// Connect calls undelying transport Connect method
func (c *Client) Connect(host string) error <span class="cov8" title="1">{
        return c.transport.Connect(host)
}</span>

// ConnectAsync calls undelying transport ConnectAsync method
func (c *Client) ConnectAsync(host string) chan bool <span class="cov8" title="1">{
        return c.transport.ConnectAsync(host)
}</span>

// Disconnect calls undelying transport Disconnect method
func (c *Client) Disconnect() <span class="cov8" title="1">{
        c.transport.Disconnect()
}</span>

// Reconnect calls undelying transport Reconnect method
func (c *Client) Reconnect() error <span class="cov8" title="1">{
        return c.transport.Reconnect()
}</span>

// ReconnectAsync calls undelying transport ReconnectAsync method
func (c *Client) ReconnectAsync() chan bool <span class="cov8" title="1">{
        return c.transport.ReconnectAsync()
}</span>

// Register registers the client with username and passowrd.
// If registration is successful server specific userId is return
// userId is used with the Athenticate method later
func (c *Client) Register(username, password string) (string, error) <span class="cov8" title="1">{
        c.username = username
        c.password = password

        payload := make(map[string]interface{})
        payload["username"] = username
        payload["password"] = password
        msg := common.NewMessage(username, "server",
                "auth", "register", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode register message", err)
                return "", err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send register message", err)
                return "", err
        }</span>

        <span class="cov8" title="1">select </span>{
        <span class="cov8" title="1">case resp := &lt;-c.Out:
                if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                        errorMessage := resp.Error()
                        log.Println("Failed to register", errorMessage)
                        return "", errors.New(errorMessage)
                }</span>

                <span class="cov8" title="1">userId := resp.GetJsonData("user_id").(string)
                log.Println("User registered", userId)
                return userId, nil</span>
        <span class="cov0" title="0">case &lt;-time.After(time.Second * 10):
                log.Println("Register response timeout")
                return "", errors.New("Register response timeout")</span>
        }
}

// Authenticate authenticates the user with is password.
// userId is obtain from Register methods earlier.
// If authentication is successful returns nil error
func (c *Client) Authenticate(userId, password string) error <span class="cov8" title="1">{
        payload := make(map[string]interface{})
        payload["user_id"] = userId
        payload["password"] = password
        msg := common.NewMessage(userId, "server",
                "auth", "auth", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode auth message", err)
                return err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send auth message", err)
                return err
        }</span>

        <span class="cov8" title="1">select </span>{
        <span class="cov8" title="1">case resp := &lt;-c.Out:
                if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                        errorMessage := resp.Error()
                        log.Println("Failed to authenticate user", errorMessage)
                        return errors.New(errorMessage)
                }</span>

                <span class="cov8" title="1">c.userId = userId
                c.authenticated = true
                authenticated := resp.GetJsonData("authenticated").(bool)
                log.Println("User authenticated", authenticated)
                return nil</span>
        <span class="cov0" title="0">case &lt;-time.After(10 * time.Second):
                log.Println("Authentication response timeout")
                return errors.New("Authentication response timeout")</span>
        }
}

// UserId return the server specific userId
func (c Client) UserId() string <span class="cov8" title="1">{
        return c.userId
}</span>

// ListContacts list the added contacts for this client
func (c *Client) ListContacts() ([]string, error) <span class="cov8" title="1">{
        var contacts []string
        if !c.authenticated </span><span class="cov0" title="0">{
                return contacts, errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov8" title="1">var payload map[string]interface{}
        msg := common.NewMessage(c.userId, "server",
                "control", "list_contacts", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode auth message", err)
                return contacts, err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send auth message", err)
                return contacts, err
        }</span>

        <span class="cov8" title="1">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("List contacts response error", errMsg)
                return contacts, errors.New(errMsg)
        }</span>

        <span class="cov8" title="1">contactsData := resp.GetJsonData("contacts")
        rawContacts, ok := contactsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return contacts, errors.New("Failed to parse contacts response")
        }</span>

        <span class="cov8" title="1">for _, rawContact := range rawContacts </span><span class="cov8" title="1">{
                contact, ok := rawContact.(string)
                if !ok </span><span class="cov0" title="0">{
                        log.Println("Failed to parse contact", rawContact)
                        continue</span>
                }

                <span class="cov8" title="1">contacts = append(contacts, contact)</span>
        }

        <span class="cov8" title="1">return contacts, nil</span>
}

// SearchContact searches for user with contactName globally on the server
func (c *Client) SearchContact(contactName string) (string, error) <span class="cov0" title="0">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return "", errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">payload := make(map[string]interface{})
        payload["contact_name"] = contactName
        msg := common.NewMessage(c.userId, "server",
                "control", "seach_contact", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode search contact message", err)
                return "", err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send search contact message", err)
                return "", err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Search contact response error", errMsg)
                return "", errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">contactId := resp.GetJsonData("contact_id").(string)
        return contactId, nil</span>
}

// AddContact adds a contact for this client
func (c *Client) AddContact(contactId string) error <span class="cov8" title="1">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov8" title="1">payload := make(map[string]interface{})
        payload["contact_id"] = contactId
        msg := common.NewMessage(c.userId, "server",
                "control", "add_contact", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode add contact message", err)
                return err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send add contact message", err)
                return err
        }</span>

        <span class="cov8" title="1">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Add contact response error", errMsg)
                return errors.New(errMsg)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Remove contact removes a contact for this client
func (c *Client) RemoveContact(contactId string) error <span class="cov0" title="0">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">payload := make(map[string]interface{})
        payload["contact_id"] = contactId
        msg := common.NewMessage(c.userId, "server",
                "control", "remove_contact", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode remove contact message", err)
                return err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send remove contact message", err)
                return err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Remove contact response error", errMsg)
                return errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateGroup creates a chat group
func (c *Client) CreateGroup() (string, error) <span class="cov0" title="0">{
        var groupId string
        if !c.authenticated </span><span class="cov0" title="0">{
                return groupId, errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">msg := common.NewMessage(c.userId, "server",
                "control", "remove_contact", time.Time{},
                common.TEXT, "")

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode create group message", err)
                return groupId, err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send create group message", err)
                return groupId, err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Create group response error", errMsg)
                return groupId, errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">groupId = resp.GetJsonData("group_id").(string)
        return groupId, nil</span>
}

// AddToGroup adds a participant in already created group
func (c *Client) AddToGroup(userId, groupId string) error <span class="cov0" title="0">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">payload := make(map[string]interface{})
        payload["group_id"] = groupId
        payload["user_id"] = userId
        msg := common.NewMessage(c.userId, "server",
                "control", "add_to_group", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode add to group message", err)
                return err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send add to group message", err)
                return err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Add to group response error", errMsg)
                return errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveFromGroup removes a participant for already created group
func (c *Client) RemoveFromGroup(userId, groupId string) error <span class="cov0" title="0">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">payload := make(map[string]interface{})
        payload["group_id"] = groupId
        payload["user_id"] = userId
        msg := common.NewMessage(c.userId, "server",
                "control", "remove_to_group", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode remove group message", err)
                return err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send remove from group message", err)
                return err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Remove from group response error", errMsg)
                return errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteGroup deletes a group
func (c *Client) DeleteGroup(groupId string) error <span class="cov0" title="0">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">payload := make(map[string]interface{})
        payload["group_id"] = groupId
        msg := common.NewMessage(c.userId, "server",
                "control", "remove_to_group", time.Time{},
                common.TEXT, payload)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode delete group message", err)
                return err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send delete group message", err)
                return err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Delete group response error", errMsg)
                return errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListGroups lists all available groups
func (c *Client) ListGroups() ([]string, error) <span class="cov0" title="0">{
        var groups []string
        if !c.authenticated </span><span class="cov0" title="0">{
                return groups, errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov0" title="0">msg := common.NewMessage(c.userId, "server",
                "control", "remove_to_group", time.Time{},
                common.TEXT, "")

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode list groups message", err)
                return groups, err
        }</span>

        <span class="cov0" title="0">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send list groups message", err)
                return groups, err
        }</span>

        <span class="cov0" title="0">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Delete group response error", errMsg)
                return groups, errors.New(errMsg)
        }</span>

        <span class="cov0" title="0">groups, _ = resp.GetJsonData("groups").([]string)
        return groups, nil</span>
}

// JoinGroup adds the client to the group
func (c *Client) JoinGroup(groupId string) error <span class="cov0" title="0">{
        return c.AddToGroup(c.userId, groupId)
}</span>

// LeaveGroup removes the client from the group
func (c *Client) LeaveGroup(groupId string) error <span class="cov0" title="0">{
        return c.RemoveFromGroup(c.userId, groupId)
}</span>

// SendMessage sends a instant message to a user or a group
func (c *Client) SendMessage(userId string, message string) error <span class="cov8" title="1">{
        return c.SendTempMessage(userId, message, time.Time{})
}</span>

// SendTempMessage sends a temporary message
// with expire period to a user or a group
func (c *Client) SendTempMessage(userId string, message string,
        expire time.Time) error <span class="cov8" title="1">{
        if !c.authenticated </span><span class="cov0" title="0">{
                return errors.New("Not authenticated. Call Authenticate first")
        }</span>

        <span class="cov8" title="1">msg := common.NewMessage(c.userId, userId,
                "message", "send_message",
                expire, common.TEXT, message)

        encoded, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode instant message", err)
                return err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(encoded))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send instant message", err)
                return err
        }</span>

        <span class="cov8" title="1">log.Println("Instant message sent")
        return nil</span>
}

// SendTextFile sends a text file to a user or a group
func (c *Client) SendTextFile(userId string, filePath string) (string, error) <span class="cov8" title="1">{
        var link string
        fileContent, err := ioutil.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to read file", err)
                return link, err
        }</span>

        <span class="cov8" title="1">msg := common.NewMessage(c.userId, userId,
                "file", "send_file", time.Time{},
                common.TEXT, string(fileContent))

        data, err := msg.Json()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to encode file", err)
                return link, err
        }</span>

        <span class="cov8" title="1">err = c.transport.SendText(string(data))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send file content", err)
                return link, err
        }</span>

        <span class="cov8" title="1">resp := &lt;-c.Out
        if resp.Status() == common.STATUS_ERROR </span><span class="cov0" title="0">{
                errMsg := resp.Error()
                log.Println("Send file response error", errMsg)
                return link, errors.New(errMsg)
        }</span>

        <span class="cov8" title="1">link = resp.String()
        log.Println("File sent", link)
        return link, nil</span>
}

// GetHistory retrieves the conversation history for a user
// or a group
func (c *Client) GetHistory(remote string, from time.Time, to time.Time) (*[]common.Message, error) <span class="cov0" title="0">{
        var messages *[]common.Message
        return messages, errors.New("Not Implemented")
}</span>

// StartInteractiveMode starts a commandline mode where you chat
// with the other users in the system
func (c *Client) StartInteractiveMode() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                reader := bufio.NewReader(os.Stdin)
                fmt.Print("Enter text: ")
                text, _ := reader.ReadString('\n')
                c.SendMessage(c.userId, text)
                resp := &lt;-c.Out
                data := resp.String()
                fmt.Println("Response: ", data)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "encoding/json"
        "errors"
        "github.com/gorilla/websocket"
        "github.com/itsankoff/gotcha/common"
        "log"
        "time"
)

// Transport implementation with a websocket
type WebSocketClient struct {
        In         chan *common.Message
        serverHost string
        conn       *websocket.Conn
}

func NewWebSocketClient() *WebSocketClient <span class="cov8" title="1">{
        return &amp;WebSocketClient{}
}</span>

func (ws *WebSocketClient) inputHandler() <span class="cov8" title="1">{
        defer ws.conn.Close()
        for </span><span class="cov8" title="1">{
                _, msg, err := ws.conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Failed to read message", err)
                        return
                }</span>

                <span class="cov8" title="1">var data map[string]interface{}
                err = json.Unmarshal(msg, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Failed to decode message", err)
                        return
                }</span>

                <span class="cov8" title="1">from := data["from"].(string)
                to := data["to"].(string)
                cmdType := data["cmd_type"].(string)
                cmd := data["cmd"].(string)
                dataType := common.DataType(data["data_type"].(float64))
                // TODO: add expire_date

                message := common.NewMessage(from, to, cmdType, cmd,
                        time.Time{}, dataType, data["data"])
                ws.In &lt;- &amp;message</span>
        }
}

func (ws *WebSocketClient) Connect(host string) error <span class="cov8" title="1">{
        if ws.In == nil </span><span class="cov0" title="0">{
                return errors.New("In channled not initialized. Call SetReceiver")
        }</span>
        <span class="cov8" title="1">c, _, err := websocket.DefaultDialer.Dial(host, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Failed to connect to server", err)
                return err
        }</span>
        <span class="cov8" title="1">ws.serverHost = host
        ws.conn = c
        go ws.inputHandler()
        return nil</span>
}

func (ws *WebSocketClient) ConnectAsync(host string) chan bool <span class="cov8" title="1">{
        connected := make(chan bool)
        go func() </span><span class="cov8" title="1">{
                err := ws.Connect(host)
                if err != nil </span><span class="cov0" title="0">{
                        connected &lt;- false
                }</span>

                <span class="cov8" title="1">connected &lt;- true</span>
        }()

        <span class="cov8" title="1">return connected</span>
}

func (ws *WebSocketClient) Disconnect() <span class="cov8" title="1">{
        if ws.conn != nil </span><span class="cov8" title="1">{
                ws.conn.Close()
        }</span>
}

func (ws *WebSocketClient) Reconnect() error <span class="cov8" title="1">{
        if ws.serverHost == "" </span><span class="cov8" title="1">{
                return errors.New("No server host provided")
        }</span>

        <span class="cov8" title="1">ws.Disconnect()
        return ws.Connect(ws.serverHost)</span>
}

func (ws *WebSocketClient) ReconnectAsync() chan bool <span class="cov8" title="1">{
        reconnected := make(chan bool)
        go func() </span><span class="cov8" title="1">{
                ws.Disconnect()
                err := ws.Connect(ws.serverHost)
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("Failed to reconnect", err)
                        reconnected &lt;- false
                }</span><span class="cov8" title="1"> else {
                        log.Println("Reconnected to", ws.serverHost)
                        reconnected &lt;- true
                }</span>
        }()

        <span class="cov8" title="1">return reconnected</span>
}

func (ws *WebSocketClient) SendText(message string) error <span class="cov8" title="1">{
        err := ws.conn.WriteMessage(websocket.TextMessage, []byte(message))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send text message", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (ws *WebSocketClient) SendBinary(data []byte) error <span class="cov0" title="0">{
        err := ws.conn.WriteMessage(websocket.TextMessage, data)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send binary message", err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (ws *WebSocketClient) SetReceiver(input chan *common.Message) <span class="cov8" title="1">{
        ws.In = input
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
